<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java练习项目分享]]></title>
      <url>%2F2017%2F03%2F26%2FJava%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%E5%88%86%E4%BA%AB%2F</url>
      <content type="text"><![CDATA[Java一味的学习只会使人感觉枯燥和无聊，在学习Java的过程中，我们总需要一些Java练习案例去检验自己的学习成果，这里给大家分享一些我自己的Java练习项目。 项目介绍本项目是个人的一些java项目练习源码，分享给大家，希望可以和大家一起进步！ Java项目实例 Woss2.0 电信采集系统 123适合java完全入门者练习，涉及到接口，xml解析，log4j应用。难度： 一般需要知识: IO流 多线程 网络编程 jdbc tomcatServlet3.0 Web服务器 123模拟tomcat服务器，帮助了解http协议难度： 易需要知识： 多线程 网络编程 checkcode Java制作验证码 123慕课教程Java制作验证码，不想看视频的可以看看难度：易需要知识： jsp/servlet 基础 IMOOCSpider 简易网络爬虫 123爬取慕课猿问问题难度：易需要知识：java基础语法，正则表达式 联系所有项目源码分享在github上，查看源码请点击——这里Please feel free to contact us with any questions you may have.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java网络爬虫项目]]></title>
      <url>%2F2017%2F03%2F19%2Fjava%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[talk is cheap, show me the code; 什么是网络爬虫？维基百科 网络爬虫（英语：web crawler），也叫网络蜘蛛（spider），是一种用来自动浏览万维网的网络机器人。其目的一般为编纂网络索引。 百度百科 网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 java网络爬虫练习项目一个比较简单的java练习项目。 需要知识 什么是网络爬虫 Java基础 正则表达式 项目思路在慕课网的猿问页面，寻找一个你喜欢的问题页面，利用http请求获取问题页面的源码，然后通过正则表达式，不断爬取相关问题页面。 项目介绍该项目存在三个类Imooc.java : imooc问题bean类Spider.java: 封装用来爬取页面的方法类Main.java: 运行起始页面 Imooc.java类是要爬取内容的对象类，属性成员有问题，问题链接，问题描述，答案列表和下一个问题链接。 Spider.java类封装了2个可能用到的方法，getSource方法获取网页源代码和getImoocPage获取页面Url列表。 项目源码IMOOCSpider项目已上传到我的github上—-传送门欢迎Star 下载下来后导入eclipse即可运行。 项目运行结果 推荐java爬取知乎问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA随机生成验证码（一）]]></title>
      <url>%2F2017%2F03%2F08%2FJAVA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[图片验证码原理： 服务器生成包含随机字符的字符串图片发给客户端，客户端提交数据需要填写字符串作为验证。而字符串保存在图片中，机器难以识别，达到防止有人利用程序恶意发送信息的目的。 JAVA随机生成图片JAVA随机生成图片步骤如下： 创建图片缓存区 传参为宽高和图片类型 12BufferedImage bi = newBufferedImage(width,height,BufferedImage.TYPE_INT_RGB); 获取画笔并绘画 1234Graphics g = bi.getGraphics(); //获取画笔g.setFont(new Font(Font.SANS_SERIF,Font.BOLD,16));//设置字体g.setColor(color);//设置画笔颜色g.fillRect(0, 0, width, height); //绘制背景 输出图片 ImageIO.write(bi, &quot;JPG&quot;, resp.getOutputStream()); JAVA实现验证码实例servlet生成验证码图片源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.javaweb.respones;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class IdentityServlet extends HttpServlet&#123;// 设置字符 public static final char[] chars=&quot;1234567890QWERTYUIOPASDFGHJKLZXCVBNM&quot;.toCharArray();// 设置随机数 public static Random random = new Random();// 获取4位随机数 public static String getRandomString()&#123; StringBuffer buffer = new StringBuffer(); int index; //获取随机chars下标 for(int i=0;i&lt;4;i++)&#123; index = random.nextInt(chars.length); //获取随机chars下标 buffer.append(chars[index]); &#125; return buffer.toString(); &#125;// 获取随机颜色 public static Color getRandomColor()&#123; return new Color(random.nextInt(255),random.nextInt(255),random.nextInt(255)); &#125;// 返回某颜色的反色 public static Color getReverseColor(Color c)&#123;// 防止反色和原色相近 if(c.getRed()&lt;130&amp;&amp;c.getRed()&gt;125 &amp;&amp; c.getBlue()&lt;130&amp;&amp; c.getBlue()&gt;125 &amp;&amp; c.getGreen()&lt;130&amp;&amp;c.getGreen()&gt;125)&#123; return new Color(255,255,255); &#125;else&#123; return new Color(255-c.getRed(),255-c.getGreen(),255-c.getBlue()); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String code = getRandomString(); //获取随机验证码 req.getSession().setAttribute(&quot;code&quot;, code); //放入Session int width = 100; //图片宽度 int height = 30; //图片高度 Color color = getRandomColor(); //随机色，用于背景色 Color reverse = getReverseColor(color); //反色，用于前景色 /** * 生成带字符串的文本图片 */// 1.创建图片缓存区 传参为宽高和图片类型 BufferedImage bi = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);// 2.获取画笔并绘画 Graphics g = bi.getGraphics(); g.setFont(new Font(Font.SANS_SERIF,Font.BOLD,16));//设置字体 g.setColor(color);//设置画笔颜色 g.fillRect(0, 0, width, height); //绘制背景 g.setColor(reverse); //设置画笔颜色 g.drawString(code, 18, 20); //绘制字符// 设置最多100个噪音点 for(int i=0,n = random.nextInt(100);i&lt;n;i++)&#123; g.drawRect(random.nextInt(width), random.nextInt(height), 1, 1); &#125;// 3.输出图片 ImageIO.write(bi, &quot;JPG&quot;, resp.getOutputStream()); &#125;&#125; 生成图片验证码主要应用随机数生成器Random生成随机颜色绘制背景，取反色*绘制字符,并绘制最多100随机位置的噪音点，增加识别难度。 配置XML12345678&lt;servlet&gt; &lt;servlet-name&gt;IdentityServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.javaweb.respones.IdentityServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;IdentityServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/IdentityServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; html展示页面1234567891011121314&lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function reloadImage()&#123; document.getElementById(&apos;btn&apos;).disable=true; document.getElementById(&apos;identity&apos;).src=&apos;servlet/IdentityServlet?time=&apos; +new Date().getTime(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src = &quot;servlet/IdentityServlet&quot; id=&quot;identity&quot; onload=&quot;btn.disabled= false;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;换个图片&quot; onclick=&quot;reloadImage()&quot; id=&quot;btn&quot;&gt; &lt;/body&gt; 截图展示 下篇介绍利用组件Jcaptcha和Kaptcha生成验证码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[现代浏览器之争]]></title>
      <url>%2F2017%2F03%2F03%2F%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BA%89%2F</url>
      <content type="text"><![CDATA[今天学习javaweb，发现一件很有趣的事情…… 用浏览器访问servlet项目，当代码执行到这地方时1234567891011121314151617/** * * 返回客户端浏览器信息 */private String getNavigator(String userAgent)&#123; if(userAgent.indexOf(&quot;TencentTraveler&quot;) &gt; 0) return &quot;腾讯浏览器&quot;; if(userAgent.indexOf(&quot;Safari&quot;)&gt;0) return &quot;Safari浏览器&quot;; if(userAgent.indexOf(&quot;Chrome&quot;)&gt;0) return &quot;Chrome浏览器&quot;; if(userAgent.indexOf(&quot;Firefox&quot;)&gt;0) return &quot;Firxfox浏览器&quot;; if(userAgent.indexOf(&quot;MSIE&quot;)&gt;0) return &quot;IE浏览器&quot;; return &quot;未知浏览器&quot;;&#125; 使用谷歌浏览器访问，居然辨识出错 打开调试器，发现谷歌的userAgent竟然有这么多的浏览器标识,这是什么情况！！！谷歌在伪装别人么… 查阅各方资料，终于找到答案： 为什么所有浏览器的userAgent都带Mozilla 最早的时候有一个浏览器叫NCSA Mosaic，把自己标称为NCSA_Mosaic/2.0 (Windows 3.1)，它支持文字显示的同时还支持图片，于是Web开始好玩起来。 然后出现了一个新的网页浏览器，“Mozilla”，其实就是“Mosaic终结者”的意思，这搞的Mosaic很不爽，（毕竟Mosaic出道早，江湖老），新浏览器最后正式公布的名称是Netscape，它把自己标称为Mozilla/1.0 (Win3.1)，更好玩了。Netscape支持框架显示，后来框架在大家中间流行起来了，但Mosaic不支持框架啊，于是伟大的“用户代-理人探测”技术出现了，如果是“Mozilla”，那就发给支持框架的页面，至于其他的浏览器，则发给不含框架的页面。 Netscape想逗Microsoft玩儿，把Windows叫做“几乎不曾做过调试的设备驱动器”，后者很恼火。Microsoft于是推出了自己的 网页浏览器，叫做Internet Explorer，希望它能成为“Netscape终结者”。Internet Explorer也支持框架，但它不是Mozilla啊，所以没人给它发送带有框架的页面。Microsoft慢慢烦躁起来，不再寄希望于网站管理员逐渐 认识IE并给它发框架，而是宣称自己是“兼容Mozilla”的，开始模仿Netscape，把自己标称为Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)，这样Internet Explorer也能收到框架了，整个Microsoft狂喜，但网站管理员开始有点被搞糊涂了。 Microsoft把IE和Windows一起卖，并且把产品也弄得比Netscape更好了，拉开了第一场浏览器之战。结果和大家知道的一样，Netscape被干掉了，Microsoft大胜、大喜。但是后来Netscape以Mozilla的新名称重生了，构造了Gecko，标称其为Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.1) Gecko/20020826，Gecko属于渲染引擎，表现优异。Mozilla开发了Firefox，标称为Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0，并且Firefox表现也非常优秀。Gecko扩张迅速，一些浏览器使用了它的代码并标称为Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7.2) Gecko/20040825 Camino/0.8.1 ，这是一个，还有Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.8) Gecko/20071008 SeaMonkey/1.0，另一个，它们都伪装成Mozilla，同时也都是基于Gecko支持的。 Gecko表现优秀，IE则很差劲，于是身份甄别再次发生，输送给Gecko的是设计良好的网页代码，其他浏览器就没有这个待遇了。Linux的跟随者很伤心，因为他们创建了基于KHTML引擎支持的Konqueror，但却不会被输送好代码，虽然他们自己认为KHTML和Gecko一样优秀，于是Konquerer开始伪装自己“像Gecko”那样以得到好的网页，并标称自己为Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)，这个世界更让人困惑了。 后来出现了Opera这样的主儿，宣称“允许用户自己决定让浏览器装成谁”，它的菜单中提供了Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51， Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51，Opera/9.51 (Windows NT 5.1; U; en) 供大家来选择，选谁是谁。 Apple开发了Safari，使用了KHTML，同时也增加了很多新特性，后来干脆一锅煮，另起炉灶叫了WebKit，但是它有希望能够得到那些为KHTML编写的网页，于是Safari标称自己为Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5，这个世界更混乱了。 Microsoft越来越担心Firefox的发展，重新启动了Internet Explorer的开发，标称自己为Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0) ，可以很好的渲染代码，但那要看网站管理员是否指示它这么做。 Google也开发了自己的浏览器Chrome， 使用了Webkit，有点像Safari，希望能得到为Safari编写的网页，于是决定装成Safari。这样啊，Chrome使用了WebKit渲染 引擎，想装成Safari，而WebKit呢又伪装自己是KHTML，KHTML呢又是伪装成Gecko的，同时所有的浏览器又都宣称自己是 Mozilla，于是，Chrome宣称自己是Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13,，UserAgent字符串彻底混乱了，也几乎不再发挥任何作用，每个人都宣称自己是别人，混乱充斥人间啊。 有点调侃的味道，可以总结为一句话：Mozilla是Netscape的吉祥物，也是Netscape Navigator浏览器使用的内部开发代号。由于Netscape早期的影响力，直到今天，所有浏览器包括IE，向Web服务器报告自己的浏览器标识的 时候，都以 “Mozilla”开头，表明自己是Mozilla兼容的。这，就是原因啦。 查看浏览器标记的方法也很容易，通过JavaScript语句： javascript:alert(navigator.userAgent) 在地址栏输入以上代码，然后回车。 答案内容转载： http://www.eamonning.com/blog/view/289]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇博客]]></title>
      <url>%2F2017%2F03%2F02%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[做人没有梦想，跟咸鱼有什么区别 为什么写博客这个问题网上的答案数不胜数为什么要写博客我为什么坚持写博客对于个人而言 记录自身成长过程是多么有意义的一件事。 网上资料数不胜数，内容参差不齐，遇到问题自己整理解决并记录下来，供自己今后学习，也方便他人查阅。 寻找志同道合的朋友 为了保持逼格，不要停止写作 现阶段现阶段奋战javaWeb开发 个性签名talk is cheap, show me the code; 联系最后，如果你想联系我，请点击以下链接： Blog@codinghjy Github@codinghjy jianshu@codinghjy 再说两句如果你想搭建想我一样酷炫的Blog请点击这里—&gt;传送门]]></content>
    </entry>

    
  
  
</search>
