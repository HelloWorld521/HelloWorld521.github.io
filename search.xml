<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[专题二：Bean ---- Spring入门笔记]]></title>
      <url>%2F2017%2F04%2F18%2FSpring%E5%85%A5%E9%97%A8-1%2F</url>
      <content type="text"><![CDATA[专题二 Bean主要内容： Bean 配置项 Bean 的作用域 Bean 的生命周期 Bean 的自动装配 Resources &amp; ResourceLoader Bean 主要配置项 Id （获取 bean） Class （获取 bean）【必须】 Scope 范围 Constructor arguments 构造器参数 （构造注入） Properties 属性（设置注入） Autowiring mode 自动装配模式 lazy-initialization mode 懒加载模式 Initialization/destruction method 初始化和销毁方法 Bean 的作用域 singleton : 单例，指一个 Bean 容器中只存在一份，context 只存在一份 prototype : 每次请求（每次使用）创建新的实例，destroy 方式不生效 request : 每次 http 请求创建一个实例且仅在当前 request 内有效 session：同上 global session：基于 portlet 的 web 中有效（portlet 定义了 global session），如果是 web 中，同 session Bean 的作用域案例Bean 类 12345678package com.imooc.bean;public class BeanScope &#123; public void say() &#123; System.out.println("BeanScope say : " + this.hashCode()); &#125;&#125; spring 配置 Beanspring-beanscope.xml123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" &gt; &lt;bean id="beanScope" class="com.imooc.bean.BeanScope" scope="singleton"&gt;&lt;/bean&gt; &lt;/beans&gt; 单元测试方法12345678910111213141516171819@RunWith(BlockJUnit4ClassRunner.class)public class TestBeanScope extends UnitTestBase &#123; public TestBeanScope() &#123; super("classpath*:spring-beanscope.xml"); &#125; @Test public void testSay() &#123; //BeanScope scope=singleton 单例 //beanScope 和 beanScope2 的 hashCode 相同 BeanScope beanScope = super.getBean("beanScope"); beanScope.say(); BeanScope beanScope2 = super.getBean("beanScope"); beanScope2.say(); &#125;&#125; 执行单元测试 testSay 方法，发现 beanScope 和 beanScope2 的 hashCode 相同，因为 scope = singleton 同一份容器中只会出现一个 bean。执行结果将 xml 文件中 singleton 改为 prototype，重新执行，执行结果 Bean 的生命周期 生命周期 定义 springxml 配置 bean 初始化 context 加载 springxml，context.start() 初始化 使用 从 Bean 容器中获取使用 销毁 Bean 容器销毁所有 Bean 实例 Bean 初始化方法 实现 org.springframework.beans.factory.InitializingBean 接口，覆盖afterPropertiesSet 方法。 配置 init-method Bean 销毁 实现 org.springframework.beans.factory.DisposableBean 接口，覆盖 destory 方法 配置 destroy-method 配置全局默认初始化、销毁方法 注：当三种方法同时使用时，先执行接口方法，然后执行 bean 配置方法，不执行默认方法。 Aware 获取资源 实现 Aware 接口的 bean 在被初始化之后，可以获取相应资源 通过 Aware 接口，可以操作 Spring 的相应资源（慎重）。 对 Spring 的简单扩展提供入口 常用 Aware 接口 ApplicationContextAware 提供 context 上下文信息 BeanNameAware 提供 BeanName（BeanId） ApplicationEventPublisherAware BeanFactoryAware BootstrapContextAware ServletConfigAware注：一般是同时实现 ApplicationContextAware 和 BeanNameAware 接口，获取到 Bean 的 Id，利用 context.getBean(id) 获取其他 Bean 资源。 Bean 的自动装配（Autowiring） （自动注入） NO：不做任何操作 byname：根据属性名自动装配 byType：装配（一个）类型相同的 Bean ，（多个）报错 Constructor：装配配合（参数类型一致）的构造器例子1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-autowire="constructor"&gt;&lt;!-- 自动装配属性 default-autowire=“NO/byname” --&gt; &lt;bean id="autoWiringService" class="com.imooc.autowiring.AutoWiringService" &gt;&lt;/bean&gt; &lt;bean class="com.imooc.autowiring.AutoWiringDAO" &gt;&lt;/bean&gt; &lt;/beans&gt; Resources &amp;&amp; ResourceLoader 针对资源文件的统一接口 Resource UrlResource：Url对应的资源 ClassPathResource：获取类路径下的资源文件 FIleSystemResource：文件系统下资源 ServletContextResource：web 环境下可以访问的资源 InputStreamResource：输入流封装的资源 ByteArrayResource：字节数组封装的资源 ResourceLoader 所有 application context 都实现 ResourceLoader 接口 加载 Resource 资源类 前缀：classpath/file/http/none(application context)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql修改密码]]></title>
      <url>%2F2017%2F04%2F12%2Fmysql%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%2F</url>
      <content type="text"><![CDATA[前言最近做毕业设计用到 mysql，但是 mysql 账号密码忘记了… mysql修改密码 以管理员权限打开 cmd ，进入 mysql 安装的 bin 目录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生AJAX实现搜索框智能提示]]></title>
      <url>%2F2017%2F03%2F31%2FAJAX%2F</url>
      <content type="text"><![CDATA[前言一直以来，使用 JQuery 来实现 AJAX 请求，感觉有必要了解一下原生 JS 实现方式。 AJAX介绍概念 AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。 优点 使用Ajax的最大优点，就是能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变的信息。 缺点 它破坏浏览器的后退与加入收藏书签功能。 解决方案 HTML5之前的一种方式是使用URL片断标识符（通常被称为锚点，即URL中#后面的部分）来保持追踪，允许用户回到指定的某个应用程序状态。（许多浏览器允许JavaScript动态更新锚点，这使得Ajax应用程序能够在更新显示内容的同时更新锚点。） HTML5 以后可以直接操作浏览历史，并以字符串形式存储网页状态，将网页加入网页收藏夹或书签时状态会被隐形地保留。 Js通用代码跨浏览器的通用方法123456789var xmlHttp;if (typeof XMLHttpRequest != "undefined") &#123; xmlHttp = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; var aVersions = ["Msxml2.XMLHttp.5.0", "Msxml2.XMLHttp.4.0", "Msxml2.XMLHttp.3.0", "Msxml2.XMLHttp", "Microsoft.XMLHttp"]; for (var i = 0; i &lt; aVersions.length; i++) &#123; try &#123; xmlHttp = new ActiveXObject(aVersions[i]); break; &#125; catch (e) &#123;&#125; &#125;&#125; 本项目介绍 搜索框智能提示的应用场景 掌握搜索框智能提示的原理 自己动手开发搜索框智能提示的功能 值得关注的点：原生 js 获取 xmlHttp 对象，前后台交互方法 应用场景搜索框，模糊搜索等 理论分析 在搜索框输入关键字 浏览器将关键字「异步」发送给服务器 服务器经过处理。将相应数据以 Json 格式返回客户端 浏览器接受服务器响应数据，解析之后使用 js 操作 dom 显示数据。 图片解析流程 重点一：数据交互采用 ajax 方式重点二：javascript 解析数据动态展示 项目核心源码分享与 Github 的 ServletAjax 项目]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[专题一：IOC ---- Spring入门笔记]]></title>
      <url>%2F2017%2F03%2F27%2FSpring%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[专题一 IOC 接口及面向接口编程 什么是 IOC（控制反转）：控制权转移，应用程序本身不负责 Spring的 Bean 配置 Bean 的初始化 Spring 的常用注入方式 接口及面向接口编程接口 接口即声明，声明哪些方法对外提供。 使用接口沟通，使其能被修改内部而不影响外部其他实体的与其交互的方式（Java8中接口可以拥有方法体） 面向接口编程 结构设计中，分清层次及调用关系，每层只向外（上层）提供一组功能的接口，各层仅依赖接口而非实现类 接口内部的实现变动不影响各层之间的调用，这一点在公共服务中尤为重要 “面向接口编程”中的“接口”是用于【隐藏具体的实现】和【实现多态性的组件】（2点） 什么是IOC IOC：控制反转，控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护 DI（依赖注入）是其一种实现方式。（获取依赖对象的过程被反转，过程由自身管理变为有 IOC 容器主动注入，即依赖注入） 目的：创建对象并且组装对象之间的关系 下图为 Spring 官网给出的 IOC 说明 Spring 的 Bean 配置配置一般存放于 spring-ioc.xml 文件中举例1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" &gt; &lt;bean id="oneInterface" class="com.imooc.ioc.interfaces.OneInterfaceImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; Bean 容器的初始化 基础：两个包 org.springframework.beans org.springframework.context BeanFactory 提供配置结构和基本功能，加载并初始化Bean ApplicationContext 保存了 Bean 对象并在 Spring 中广泛使用 3中初始化方式：ApplicationContext 本地文件 12FileSystemXmlApplicationContext context = newFileSystemXmlApplicationContext("F:/workspace/appcontext.xml"); Classpath 12ClassPathXmlApplicationContext context = newClassPathXmlApplicationContext("classpath:spring-context.xml"); Web 应用中依赖 servlet 或 Listener Spring 注入 Spring 注入指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为 常用的两种注入方式 设值注入 构造注入 设值注入123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" &gt; &lt;bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl"&gt; &lt;property name="injectionDAO" ref="injectionDAO"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="injectionDAO" class="com.imooc.ioc.injection.dao.InjectionDAOImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 注意：需要在 Service 文件中添加 setInjectionDAO 方法。property 中 name 对应 set* 构造注入123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" &gt; &lt;bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl"&gt; &lt;constructor-arg name="injectionDAO" ref="injectionDAO"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="injectionDAO" class="com.imooc.ioc.injection.dao.InjectionDAOImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 注意：需要在 Service 文件中添加构造方法。name 对应 service 中构造器参数名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java练习项目分享]]></title>
      <url>%2F2017%2F03%2F26%2FJava%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%E5%88%86%E4%BA%AB%2F</url>
      <content type="text"><![CDATA[Java一味的学习只会使人感觉枯燥和无聊，在学习Java的过程中，我们总需要一些Java练习案例去检验自己的学习成果，这里给大家分享一些我自己的Java练习项目。 项目介绍本项目是个人的一些java项目练习源码，分享给大家，希望可以和大家一起进步！ Java项目实例 Woss2.0 电信采集系统 123适合java完全入门者练习，涉及到接口，xml解析，log4j应用。难度： 一般需要知识: IO流 多线程 网络编程 jdbc tomcatServlet3.0 Web服务器 123模拟tomcat服务器，帮助了解http协议难度： 易需要知识： 多线程 网络编程 checkcode Java制作验证码 123慕课教程Java制作验证码，不想看视频的可以看看难度：易需要知识： jsp/servlet 基础 IMOOCSpider 简易网络爬虫 123爬取慕课猿问问题难度：易需要知识：java基础语法，正则表达式 联系所有项目源码分享在github上，查看源码请点击——这里Please feel free to contact us with any questions you may have.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java网络爬虫项目]]></title>
      <url>%2F2017%2F03%2F19%2Fjava%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[talk is cheap, show me the code; 什么是网络爬虫？维基百科 网络爬虫（英语：web crawler），也叫网络蜘蛛（spider），是一种用来自动浏览万维网的网络机器人。其目的一般为编纂网络索引。 百度百科 网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 java网络爬虫练习项目一个比较简单的java练习项目。 需要知识 什么是网络爬虫 Java基础 正则表达式 项目思路在慕课网的猿问页面，寻找一个你喜欢的问题页面，利用http请求获取问题页面的源码，然后通过正则表达式，不断爬取相关问题页面。 项目介绍该项目存在三个类Imooc.java : imooc问题bean类Spider.java: 封装用来爬取页面的方法类Main.java: 运行起始页面 Imooc.java类是要爬取内容的对象类，属性成员有问题，问题链接，问题描述，答案列表和下一个问题链接。 Spider.java类封装了2个可能用到的方法，getSource方法获取网页源代码和getImoocPage获取页面Url列表。 项目源码IMOOCSpider项目已上传到我的github上—-传送门欢迎Star 下载下来后导入eclipse即可运行。 项目运行结果 推荐java爬取知乎问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA随机生成验证码（一）]]></title>
      <url>%2F2017%2F03%2F08%2FJAVA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[图片验证码原理： 服务器生成包含随机字符的字符串图片发给客户端，客户端提交数据需要填写字符串作为验证。而字符串保存在图片中，机器难以识别，达到防止有人利用程序恶意发送信息的目的。 JAVA随机生成图片JAVA随机生成图片步骤如下： 创建图片缓存区 传参为宽高和图片类型 12BufferedImage bi = newBufferedImage(width,height,BufferedImage.TYPE_INT_RGB); 获取画笔并绘画 1234Graphics g = bi.getGraphics(); //获取画笔g.setFont(new Font(Font.SANS_SERIF,Font.BOLD,16));//设置字体g.setColor(color);//设置画笔颜色g.fillRect(0, 0, width, height); //绘制背景 输出图片 1ImageIO.write(bi, "JPG", resp.getOutputStream()); JAVA实现验证码实例servlet生成验证码图片源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.javaweb.respones;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class IdentityServlet extends HttpServlet&#123;// 设置字符 public static final char[] chars="1234567890QWERTYUIOPASDFGHJKLZXCVBNM".toCharArray();// 设置随机数 public static Random random = new Random();// 获取4位随机数 public static String getRandomString()&#123; StringBuffer buffer = new StringBuffer(); int index; //获取随机chars下标 for(int i=0;i&lt;4;i++)&#123; index = random.nextInt(chars.length); //获取随机chars下标 buffer.append(chars[index]); &#125; return buffer.toString(); &#125;// 获取随机颜色 public static Color getRandomColor()&#123; return new Color(random.nextInt(255),random.nextInt(255),random.nextInt(255)); &#125;// 返回某颜色的反色 public static Color getReverseColor(Color c)&#123;// 防止反色和原色相近 if(c.getRed()&lt;130&amp;&amp;c.getRed()&gt;125 &amp;&amp; c.getBlue()&lt;130&amp;&amp; c.getBlue()&gt;125 &amp;&amp; c.getGreen()&lt;130&amp;&amp;c.getGreen()&gt;125)&#123; return new Color(255,255,255); &#125;else&#123; return new Color(255-c.getRed(),255-c.getGreen(),255-c.getBlue()); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String code = getRandomString(); //获取随机验证码 req.getSession().setAttribute("code", code); //放入Session int width = 100; //图片宽度 int height = 30; //图片高度 Color color = getRandomColor(); //随机色，用于背景色 Color reverse = getReverseColor(color); //反色，用于前景色 /** * 生成带字符串的文本图片 */// 1.创建图片缓存区 传参为宽高和图片类型 BufferedImage bi = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);// 2.获取画笔并绘画 Graphics g = bi.getGraphics(); g.setFont(new Font(Font.SANS_SERIF,Font.BOLD,16));//设置字体 g.setColor(color);//设置画笔颜色 g.fillRect(0, 0, width, height); //绘制背景 g.setColor(reverse); //设置画笔颜色 g.drawString(code, 18, 20); //绘制字符// 设置最多100个噪音点 for(int i=0,n = random.nextInt(100);i&lt;n;i++)&#123; g.drawRect(random.nextInt(width), random.nextInt(height), 1, 1); &#125;// 3.输出图片 ImageIO.write(bi, "JPG", resp.getOutputStream()); &#125;&#125; 生成图片验证码主要应用随机数生成器Random生成随机颜色绘制背景，取反色*绘制字符,并绘制最多100随机位置的噪音点，增加识别难度。 配置XML12345678&lt;servlet&gt; &lt;servlet-name&gt;IdentityServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.javaweb.respones.IdentityServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;IdentityServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/IdentityServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; html展示页面1234567891011121314&lt;head&gt; &lt;script type="text/javascript"&gt; function reloadImage()&#123; document.getElementById('btn').disable=true; document.getElementById('identity').src='servlet/IdentityServlet?time=' +new Date().getTime(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src = "servlet/IdentityServlet" id="identity" onload="btn.disabled= false;"&gt; &lt;input type="button" value="换个图片" onclick="reloadImage()" id="btn"&gt; &lt;/body&gt; 截图展示 下篇介绍利用组件Jcaptcha和Kaptcha生成验证码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[现代浏览器之争]]></title>
      <url>%2F2017%2F03%2F03%2F%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BA%89%2F</url>
      <content type="text"><![CDATA[今天学习javaweb，发现一件很有趣的事情…… 用浏览器访问servlet项目，当代码执行到这地方时1234567891011121314151617/** * * 返回客户端浏览器信息 */private String getNavigator(String userAgent)&#123; if(userAgent.indexOf(&quot;TencentTraveler&quot;) &gt; 0) return &quot;腾讯浏览器&quot;; if(userAgent.indexOf(&quot;Safari&quot;)&gt;0) return &quot;Safari浏览器&quot;; if(userAgent.indexOf(&quot;Chrome&quot;)&gt;0) return &quot;Chrome浏览器&quot;; if(userAgent.indexOf(&quot;Firefox&quot;)&gt;0) return &quot;Firxfox浏览器&quot;; if(userAgent.indexOf(&quot;MSIE&quot;)&gt;0) return &quot;IE浏览器&quot;; return &quot;未知浏览器&quot;;&#125; 使用谷歌浏览器访问，居然辨识出错 打开调试器，发现谷歌的userAgent竟然有这么多的浏览器标识,这是什么情况！！！谷歌在伪装别人么… 查阅各方资料，终于找到答案： 为什么所有浏览器的userAgent都带Mozilla 最早的时候有一个浏览器叫NCSA Mosaic，把自己标称为NCSA_Mosaic/2.0 (Windows 3.1)，它支持文字显示的同时还支持图片，于是Web开始好玩起来。 然后出现了一个新的网页浏览器，“Mozilla”，其实就是“Mosaic终结者”的意思，这搞的Mosaic很不爽，（毕竟Mosaic出道早，江湖老），新浏览器最后正式公布的名称是Netscape，它把自己标称为Mozilla/1.0 (Win3.1)，更好玩了。Netscape支持框架显示，后来框架在大家中间流行起来了，但Mosaic不支持框架啊，于是伟大的“用户代-理人探测”技术出现了，如果是“Mozilla”，那就发给支持框架的页面，至于其他的浏览器，则发给不含框架的页面。 Netscape想逗Microsoft玩儿，把Windows叫做“几乎不曾做过调试的设备驱动器”，后者很恼火。Microsoft于是推出了自己的 网页浏览器，叫做Internet Explorer，希望它能成为“Netscape终结者”。Internet Explorer也支持框架，但它不是Mozilla啊，所以没人给它发送带有框架的页面。Microsoft慢慢烦躁起来，不再寄希望于网站管理员逐渐 认识IE并给它发框架，而是宣称自己是“兼容Mozilla”的，开始模仿Netscape，把自己标称为Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)，这样Internet Explorer也能收到框架了，整个Microsoft狂喜，但网站管理员开始有点被搞糊涂了。 Microsoft把IE和Windows一起卖，并且把产品也弄得比Netscape更好了，拉开了第一场浏览器之战。结果和大家知道的一样，Netscape被干掉了，Microsoft大胜、大喜。但是后来Netscape以Mozilla的新名称重生了，构造了Gecko，标称其为Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.1) Gecko/20020826，Gecko属于渲染引擎，表现优异。Mozilla开发了Firefox，标称为Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0，并且Firefox表现也非常优秀。Gecko扩张迅速，一些浏览器使用了它的代码并标称为Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7.2) Gecko/20040825 Camino/0.8.1 ，这是一个，还有Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.8) Gecko/20071008 SeaMonkey/1.0，另一个，它们都伪装成Mozilla，同时也都是基于Gecko支持的。 Gecko表现优秀，IE则很差劲，于是身份甄别再次发生，输送给Gecko的是设计良好的网页代码，其他浏览器就没有这个待遇了。Linux的跟随者很伤心，因为他们创建了基于KHTML引擎支持的Konqueror，但却不会被输送好代码，虽然他们自己认为KHTML和Gecko一样优秀，于是Konquerer开始伪装自己“像Gecko”那样以得到好的网页，并标称自己为Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)，这个世界更让人困惑了。 后来出现了Opera这样的主儿，宣称“允许用户自己决定让浏览器装成谁”，它的菜单中提供了Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51， Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51，Opera/9.51 (Windows NT 5.1; U; en) 供大家来选择，选谁是谁。 Apple开发了Safari，使用了KHTML，同时也增加了很多新特性，后来干脆一锅煮，另起炉灶叫了WebKit，但是它有希望能够得到那些为KHTML编写的网页，于是Safari标称自己为Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5，这个世界更混乱了。 Microsoft越来越担心Firefox的发展，重新启动了Internet Explorer的开发，标称自己为Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0) ，可以很好的渲染代码，但那要看网站管理员是否指示它这么做。 Google也开发了自己的浏览器Chrome， 使用了Webkit，有点像Safari，希望能得到为Safari编写的网页，于是决定装成Safari。这样啊，Chrome使用了WebKit渲染 引擎，想装成Safari，而WebKit呢又伪装自己是KHTML，KHTML呢又是伪装成Gecko的，同时所有的浏览器又都宣称自己是 Mozilla，于是，Chrome宣称自己是Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13,，UserAgent字符串彻底混乱了，也几乎不再发挥任何作用，每个人都宣称自己是别人，混乱充斥人间啊。 有点调侃的味道，可以总结为一句话：Mozilla是Netscape的吉祥物，也是Netscape Navigator浏览器使用的内部开发代号。由于Netscape早期的影响力，直到今天，所有浏览器包括IE，向Web服务器报告自己的浏览器标识的 时候，都以 “Mozilla”开头，表明自己是Mozilla兼容的。这，就是原因啦。 查看浏览器标记的方法也很容易，通过JavaScript语句： javascript:alert(navigator.userAgent) 在地址栏输入以上代码，然后回车。 答案内容转载： http://www.eamonning.com/blog/view/289]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇博客]]></title>
      <url>%2F2017%2F03%2F02%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[做人没有梦想，跟咸鱼有什么区别 为什么写博客这个问题网上的答案数不胜数为什么要写博客我为什么坚持写博客对于个人而言 记录自身成长过程是多么有意义的一件事。 网上资料数不胜数，内容参差不齐，遇到问题自己整理解决并记录下来，供自己今后学习，也方便他人查阅。 寻找志同道合的朋友 为了保持逼格，不要停止写作 现阶段现阶段奋战javaWeb开发 个性签名talk is cheap, show me the code; 联系最后，如果你想联系我，请点击以下链接： Blog@codinghjy Github@codinghjy jianshu@codinghjy 再说两句如果你想搭建想我一样酷炫的Blog请点击这里—&gt;传送门]]></content>
    </entry>

    
  
  
</search>
