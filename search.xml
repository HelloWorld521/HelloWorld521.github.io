<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python 高级特性（廖雪峰版）]]></title>
      <url>%2F2018%2F05%2F25%2FPython-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%88%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%89%88%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Python 高级特性 切片 Slice切片 主要是对 list&amp;tuple 索引进行操作 迭代 Iteration使用for ... in 进行迭代操作 Iterable：可迭代对象 isinstance(str, Iterable)： 是否为可迭代对象enumerate(list)： 将 list 转化为索引-元素对 列表生产式 List Comprehensionseg：生成10以内仅偶数的平方集合[x*x for x in range(1,11) if x%2==0] 生产器 generatorgererator: 一边循环一边计算的机制,通过循环推算后续的元素，保存算法定义 generator 使用 yield 输出关键字。123456### 生成器 作业 杨辉三角 def triangles(): L=[1] while True: yield L L = [1]+[L[x]+L[x+1] for x in range(len(L)-1)] +[1] 迭代器 Iterator迭代器： 可以被next()函数调用并不断返回下一个值的对象 isinstance(str, Iterator)： 是否为迭代器iter(str)： 将str list dict转化为迭代器 Python 函数式编程函数式编程 Functional Programming函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ Python 对函数式编程提供部分支持。 高阶函数 Higher-order function 变量可以指向函数 函数名是指向函数的变量 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 map/reduce 函数map(函数, Iterable)： 两个参数，第一个为函数，第二个为可迭代对象，将函数依次作用到 Iterable 的每个元素，将结果作为 Iterator 返回。reduce(函数, Iterable)： 将函数的结果和 iterable 的下一元素做累积计算，函数必须接受两个参。 1234567891011# eg：str to intfrom functools import reduceDIGITS = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;def str2int(s): def fn(x, y): return x * 10 + y def char2num(s): return DIGITS[s] return reduce(fn, map(char2num, s)) filter 函数filter 用于过滤序列 filter(函数, iterable)： 将函数依次作用于每个元素，根据返回值是Ture还是false决定保留还是丢弃该元素。返回结果Iterator 123456789101112131415161718192021# 练习 filter求素数# 从3开始的奇数序列def _odd_iter(): n = 1 while True: n = n + 2 yield n # 定义筛选函数def _not_divisible(n): return lambda x:x%n&gt;0 # 定义def primes(): yield 2 it = _odd_tier() # 初始序列 while True: n = next(it) # 返回序列第一个数 yield n it = filter(_not_divisible(n), it) sorted 排序sorted(list, key=函数, reverse=True)： 接收一个key函数，对list进行排序，reverse确定是否反向排序 返回函数高阶函数可以接受函数作为参数，也可以把函数作为结果返回 12345678# eg 返回求和的函数def lazy_sum(*args): def sum(): ax = 0 for x in args: ax = ax + n return ax return sum 闭包问题注意：返回的函数中引用了局部变量args，当返回一个函数后，其内部的局部变量还被新的函数引用。 ！返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用，在创建一个函数，将变量作为参数绑定当前值 1.内部函数一般无法修改外部函数的参数2.想要修改需要声明 nonlocal3.内部函数可以修改外部list中的元素 匿名函数关键字lambda标识匿名函数，:之前为参数，之后为返回结果 装饰器（Decorator）装饰器 在代码运行期间动态增强功能的方式，本质上是一个装饰器 123456789101112131415# eg 定义一个能打印日志的decoratordef log(text): def decorator(func): # 防止name改变 @functools.wraps(func) def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator # 用法@log('execute') def func()...# 相当于func = log('execute')func]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python 基础（廖雪峰版）]]></title>
      <url>%2F2018%2F05%2F25%2FPython%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%89%88%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Python 基础数据类型和变量12345整数 浮点数 字符串 布尔值 空值（None） 变量变量本身类型不固定 动态语言 常量不能变的变量使用大写的变量名标识常亮 精确除法 /整数除法 //余数 % 字符编码ASCII 码： 127个字符（一字节）UTF-8： 可变长编码，包含ASCII编码Unicode： 统一各国语音到一套编码里（常用两字节） ord(s)： 获取字符的整数表示chr(编码)： 编码转化为对应字符str.encode(‘utf-8’)： 字符串转化为指定编码的字节码b’\xe4’.decode(‘uft-8’)： 字节码转化为字符串 注意：计算机内存中统一使用 Unicode 编码，需要保存硬盘或者需要传输转换为UTF-8编码 格式化同 C 语言一致：‘%d’ 整数‘%f’ 浮点数‘%s’ 字符串‘%x’ 十六进制整数 format(): 格式化方法，替换占位符 list&amp;tuplelist：可变的有序表 [] append(‘’)： 追加元素insert(i, ‘’)： 插入元素pop(i)： 删除元素 tuple：指向不可变的有序列表 (1,) 条件判断和循环if … elif … else: …for x in …while 循环 dict&amp;setdict：字典dictionary 类似 map(key-value) 具有极快的查找速度，key 是不可变对象。 in： 判断 key 是否存在get()： 获取元素pop()： 删除元素 与 list 比较，dict 特点： 查找插入速度快，不随 key 增加变慢 占用大量内存，浪费内存多 list特点： 查找和插入随着元素的增加而增加 占用空间小，浪费内存少 set: 无序的 key 值集合。 set([])： 生成 set 集合add(key)： 添加元素remove(key)： 删除元素 Python 函数内置函数运算函数abs() mix() max()数据类型转化int() float() str() bool() 自定义函数12def funcname(): return 1 空函数 12def funcname(): pass 递归函数 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你没有迟到，只是活在自己的时区里]]></title>
      <url>%2F2017%2F09%2F28%2F%E4%BD%A0%E6%B2%A1%E6%9C%89%E8%BF%9F%E5%88%B0%EF%BC%8C%E5%8F%AA%E6%98%AF%E6%B4%BB%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E5%8C%BA%E9%87%8C%2F</url>
      <content type="text"><![CDATA[在命运为你安排的属于自己的时区里，一切都准时。 纽约时间比加州时间早三个小时，New York is 3 hours ahead of California, 但加州时间并没有变慢。but it does not make California slow. 有人22岁就毕业了，Someone graduated at the age of 22, 但等了五年才找到好的工作！but waited 5 years before securing a good job! 有人25岁就当上CEO，Someone became a CEO at 25, 却在50岁去世。and died at 50. 也有人迟到50岁才当上CEO，While another became a CEO at 50, 然后活到90岁。and lived to 90 years. 有人依然单身，Someone is still single, 同时也有人已婚。while someone else got married. 奥巴马55岁就退休，Obama retires at 55, 川普70岁才开始当总统。but Trump starts at 70. 世上每个人本来就有自己的发展时区。Absolutely everyone in this world works based on their Time Zone. 身边有些人看似走在你前面，People around you might seem to go ahead of you, 也有人看似走在你后面。some might seem to be behind you. 但其实每个人在自己的时区有自己的步程。But everyone is running their own RACE, in their own TIME. 不用嫉妒或嘲笑他们。Don’t envy them or mock them. 他们都在自己的时区里，你也是！They are in their TIME ZONE, and you are in yours! 生命就是等待正确的行动时机。Life is about waiting for the right moment to act. 所以，放轻松。So, RELAX. 你没有落后。You’re not LATE. 你没有领先。You’re not EARLY. 在命运为你安排的属于自己的时区里，一切都准时。You are very much ON TIME, and in your TIME ZONE Destiny set up for you.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深度学习第一周（二）]]></title>
      <url>%2F2017%2F09%2F23%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[目标 Regression Models (回归模型) 学习 Scikit-Learn 搭建回归模型 准备工作及知识环境配置 选择 Python2 版本 1conda create -n siraj-regression python=2 安装 pandas,matplotlib,scikit-learn 1conda install pandas matplotlib scikit-learn 参考资料 Pandas (Python 数据处理库) Scikit-learn (综合性 Python 机器学习库) Matplotlib (Matplotlib 官方教程) Siraj 的线性回归Youtobe 地址 ：Siraj 内容： 使用线性回归计算脑容量和体重之间的关系 操作步骤 环境配置（创建环境，进入环境，安装包） 123conda create -n siraj-regression python=2activate siraj-regressionconda install pandas matplotlib scikit-learn 下载训练数据文件 1git clone https://github.com/llSourcell/linear_regression_demo.git 执行 demo.py效果如图： 线性回归注意线性回归隐含一系列前提假设，并非适合所有情形，因此注意两个问题 适用于线性数据如果训练数据包含非线性关系，你需要：调整数据，增加特征值数量或选用其他模型 容易受异常值影响数据集中存在不符合总体规律的异常值时，会影响最终结果 多元线性回归只有单个预测变量时，线性模型公式为 $y = mx$两个预测变量时，预测公式为 $y = m_1x_1+m_2x_2+b$多个预测变量同理，不影响编程 线性回归练习题目： 构建线性回归模型，根据各国男性人口的 身体质量指数 (BMI) 来预测该国人口平均寿命。绘制线形图并预测 BMI 为 21 的寿命 提示： 仿照 demo.py 利用 pandas 的函数 read_csv 读取 bmi_and_life.csv 文件 构建 sklearn 的线性模型并训练 利用 matplotlib.pyplot 绘图 数据文件 bmi_and_life.csv 点这里 答案：点这里 bmi_and_life.py 文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深度学习第一周(一)]]></title>
      <url>%2F2017%2F09%2F21%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8%2F</url>
      <content type="text"><![CDATA[Udacity的深度学习9月20号开课了，花了我 4000 大洋，可是要认真做笔记了。 刚开始就先让体验了一下 fast-style-transfer 图片风格转换，的确是一件挺好玩的事，在这里就给大家分享一下。 效果展示 效果确实很抽象。 环境搭建 安装地址：Anaconda 选择你喜欢的版本（我的是Anaconda3-4.4 64位） 安装过程就不说了，完成之后打开 Anaconda Prompt 终端，输入conda upgrade --all，更新所有包 win 环境需要安装 TensorFlow 0.12.1、Python 3.5、Pillow 3.4.2、scipy 0.18.1 和 numpy 1.11.2 1234conda create -n style-transfer python=3.5activate style-transferpip install -i https://pypi.tuna.tsinghua.edu.cn/simple tensorflowconda install scipy pillow 以上代码意思是创建python3.5的环境，进入此环境，并且在此环境下使用清华源安装tensorflow，使用 conda 安装 scipy和pillow。 下载 fast-style-transfer GitHub 资源库代码 1git clone https://github.com/lengstrom/fast-style-transfer.git fast-style-transfer 项目需要自己训练图片风格，然后将图片转换为你训练的风格。这里提供几种训练好的数据集，下载任意一个到fast-style-transfer 项目文件夹下。 La Muse Rain Princess Udnie Scream Wave Wreck 在之前的 style-transfer 的环境下，进入 fast-style-transfer 的文件夹输入 1python evaluate.py --checkpoint ./rain-princess.ckpt --in-path &lt;path_to_input_file&gt; --out-path ./output_image.jpg &lt;path_to_input_file&gt; 为要转换图片的位置，./rain-princess.ckpt 为训练的数据集，./output_image.jpg 为转换后的图片。注意不要转换太大的图片。 温馨建议 转换图片大小不要超过200k 微信不支持外链，点击原文链接跳转到我的博客查看，或者给我发送消息“风格转换”，我将训练集链接发给你。 建议不要转化美女图片，也不要问我为什么，辣眼睛我不想说。 资料Anaconda和conda介绍Jupyter notebook 介绍]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python练习题（三）-视频展示网站]]></title>
      <url>%2F2017%2F09%2F21%2FPython%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89-%E8%A7%86%E9%A2%91%E5%B1%95%E7%A4%BA%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[题目来源：优达学城–编程基础：python内容：寻找自己喜欢的视频，做成网站展示出来效果演示： 源代码主要有三个.py文件，放到一个文件夹中，运行 entertainment_center.py 即可。（需要python环境）源码地址 : Python-Exercies网站地址 : 视频展示网站 其他对优达源码做了改动，支持多种视频格式，导入codecs包，写入html支持中文。无法观看的是嵌入youtube视频（翻墙即可）。 附源码entertainment_center.py123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-import mediaimport fresh_tomatoesoverwatch = media.Movie("Overwatch","守望者们回归", "http://overwatch.nos.netease.com/2/media/Wallpapers/Genji_wallpaper/2048x2048.jpg", "http://flv.bn.netease.com/videolib3/1506/26/cJtFW2189/HD/cJtFW2189-mobile.mp4")school_of_rock = media.Movie("School of Rock"," Using rock music to learn", "http://upload.wikimedia.org/wikipedia/en/thumb/1/11/School_of_Rock_Poster.jpg/220px-School_of_Rock_Poster.jpg", "https://www.youtube.com/watch?v=3PsUJFEBC74")spider_gay = media.Movie("美队3 内战","搞笑蜘蛛侠", "http://p1.ifengimg.com/a/2016_19/ea0b92b08ab62d2_size47_w550_h275.jpg", "https://www.youtube.com/watch?time_continue=16&amp;v=Wa5yWjsjGoI")overwatch2 = media.Movie("双龙","双龙", "http://overwatch.nos.netease.com/2/media/videos/dragons-animated-short.jpg", "http://flv.bn.netease.com/videolib3/1605/16/nTaMi2329/HD/nTaMi2329-mobile.mp4")overwatch3 = media.Movie("虚幻争霸","虚幻争霸试玩", "https://i.ytimg.com/vi/l-TAaE5raeU/hqdefault.jpg", "https://www.youtube.com/watch?v=l-TAaE5raeU")overwatch4 = media.Movie("LOL","盘点lol最强操作", "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSLfycX_SZr4pT-UVddhr0FdcN67cX1rwFM21PPH3glYPETzGtT", "http://r.plures.net/plu/tplayer/video-iath80mu.swf?vid=w0162pdtuoi&amp;auto=1")movies = [overwatch, school_of_rock, spider_gay, overwatch2, overwatch3, overwatch4]fresh_tomatoes.open_movies_page(movies)#print(media.Movie.__name__)#print(media.Movie.__module__)#print(media.Movie.__doc__) fresh_tomatoes.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171# -*- coding: utf-8 -*-import codecsimport webbrowserimport osimport re# Styles and scripting for the pagemain_page_head = '''&lt;!DOCTYPE html&gt;s&lt;html lang="zh_CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Fresh Tomatoes!&lt;/title&gt; &lt;!-- Bootstrap 3 --&gt; &lt;link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css"&gt; &lt;link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css"&gt; &lt;script src="http://code.jquery.com/jquery-1.10.1.min.js"&gt;&lt;/script&gt; &lt;script src="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;style type="text/css" media="screen"&gt; body &#123; padding-top: 80px; &#125; #trailer .modal-dialog &#123; margin-top: 200px; width: 640px; height: 480px; &#125; .hanging-close &#123; position: absolute; top: -12px; right: -12px; z-index: 9001; &#125; #trailer-video &#123; width: 100%; height: 100%; &#125; .movie-tile &#123; margin-bottom: 20px; padding-top: 20px; &#125; .movie-tile:hover &#123; background-color: #EEE; cursor: pointer; &#125; .scale-media &#123; padding-bottom: 56.25%; position: relative; &#125; .scale-media iframe &#123; border: none; height: 100%; position: absolute; width: 100%; left: 0; top: 0; background-color: white; &#125; &lt;/style&gt; &lt;script type="text/javascript" charset="utf-8"&gt; // Pause the video when the modal is closed $(document).on('click', '.hanging-close, .modal-backdrop, .modal', function (event) &#123; // Remove the src so the player itself gets removed, as this is the only // reliable way to ensure the video stops playing in IE $("#trailer-video-container").empty(); &#125;); // Start playing the video whenever the trailer modal is opened $(document).on('click', '.movie-tile', function (event) &#123; var trailerYouTubeId = $(this).attr('data-trailer-youtube-id'); var sourceUrl = trailerYouTubeId ; $("#trailer-video-container").empty().append($("&lt;iframe&gt;&lt;/iframe&gt;", &#123; 'id': 'trailer-video', 'type': 'text-html', 'src': sourceUrl, 'frameborder': 0 &#125;)); &#125;); // Animate in the movies when the page loads $(document).ready(function () &#123; $('.movie-tile').hide().first().show("fast", function showNext() &#123; $(this).next("div").show("fast", showNext); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;'''# The main page layout and title barmain_page_content = ''' &lt;body&gt; &lt;!-- Trailer Video Modal --&gt; &lt;div class="modal" id="trailer"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;a href="#" class="hanging-close" data-dismiss="modal" aria-hidden="true"&gt; ![](https://lh5.ggpht.com/v4-628SilF0HtHuHdu5EzxD7WRqOrrTIDi_MhEG6_qkNtUK5Wg7KPkofp_VJoF7RS2LhxwEFCO1ICHZlc-o_=s0#w=24&amp;h=24) &lt;/a&gt; &lt;div class="scale-media" id="trailer-video-container"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Main Page Content --&gt; &lt;div class="container"&gt; &lt;div class="navbar navbar-inverse navbar-fixed-top" role="navigation"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;a class="navbar-brand" href="#"&gt;Fresh Tomatoes Movie Trailers&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="container"&gt; &#123;movie_tiles&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;'''# A single movie entry html templatemovie_tile_content = '''&lt;div class="col-md-6 col-lg-4 movie-tile text-center" data-trailer-youtube-id="&#123;trailer_youtube_id&#125;" data-toggle="modal" data-target="#trailer"&gt; ![](&#123;poster_image_url&#125;) &lt;h2&gt;&#123;movie_title&#125;&lt;/h2&gt;&lt;/div&gt;'''def create_movie_tiles_content(movies): # The HTML content for this section of the page content = '' for movie in movies: # Extract the youtube ID from the url youtube_id_match = re.search( r'(?&lt;=v=)[^&amp;#]+', movie.trailer_url) if youtube_id_match: youtube_id_match = 'http://www.youtube.com/embed/' + youtube_id_match.group(0) + '?autoplay=1&amp;html5=1'; else : youtube_id_match = movie.trailer_url trailer_youtube_id = youtube_id_match # Append the tile for the movie with its content filled in content += movie_tile_content.format( movie_title=movie.title, poster_image_url=movie.poster_image_url, trailer_youtube_id=trailer_youtube_id ) return contentdef open_movies_page(movies): # Create or overwrite the output file output_file = codecs.open('fresh_tomatoes.html', 'w',encoding='utf-8') # Replace the movie tiles placeholder generated content rendered_content = main_page_content.format( movie_tiles=create_movie_tiles_content(movies)) # Output the file output_file.write(main_page_head + rendered_content) output_file.close() # open the output file in the browser (in a new tab, if possible) url = os.path.abspath(output_file.name) webbrowser.open('file://' + url, new=2) media.py1234567891011121314import webbrowserclass Movie(): """This class provides a way to store movie related information """ VALID_RATINGS = ["G", "PG", "PG-13", "R"] def __init__(self, movie_title, movie_storyline, poster_image, trailer): self.title = movie_title self.storyline = movie_storyline self.poster_image_url = poster_image self.trailer_url = trailer def show_trailer(self): webbrowser.open(self.trailer_url)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python练习题（二）-画图形]]></title>
      <url>%2F2017%2F09%2F21%2FPython%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%94%BB%E5%9B%BE%E5%BD%A2%2F</url>
      <content type="text"><![CDATA[题目来源： 优达学城–编程基础：python内容：使用 turtle 画出你想象。效果演示： 我的解法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import turtle#def draw_name():def draw_h(pen): pen.down() pen.right(90) pen.forward(100) pen.backward(50) pen.left(90) pen.forward(50) pen.right(90) pen.forward(50) pen.backward(100) pen.left(90)def draw_j(pen): pen.up() pen.forward(25) pen.down() pen.forward(50) pen.backward(25) pen.right(90) pen.forward(100) pen.right(90) pen.forward(25) pen.right(90) pen.forward(25) pen.right(90)def draw_y(pen): x = pen.xcor() y = pen.ycor() pen.goto(x+25,y-50) pen.goto(x+50,y) pen.goto(x+25,y-50) pen.right(90) pen.forward(50) pen.left(90)def draw_flower(pen): for i in range(0,36): for i in range(0,2): pen.forward(50) pen.right(60) pen.forward(50) pen.right(120) pen.right(10) pen.right(90) pen.forward(200)def draw_art(): pen = turtle.Turtle() pen.color("yellow") pen.shape("turtle") pen.speed(8) window = turtle.Screen() window.bgcolor("red") draw_h(pen) pen.up() pen.forward(10) draw_j(pen) pen.up() pen.goto(170,0) pen.down() draw_y(pen) pen.up() pen.goto(-100,100) pen.down() draw_flower(pen) window.exitonclick()draw_art() 12345678910111213141516171819202122232425262728293031323334353637383940import turtledef draw_circle(angie): angie.circle(50)def draw_triangle(triangle): for y in range(0,3): triangle.forward(100) triangle.right(120)def draw_square(turtle): for i in range(0,4): turtle.forward(100) turtle.right(90)def draw_art(): window = turtle.Screen() window.bgcolor("red") brad = turtle.Turtle() brad.shape("turtle") brad.speed(15) # 循环方形 for i in range(0,36): brad.color("pink") draw_triangle(brad) brad.color("blue") draw_circle(brad) brad.color("yellow") draw_square(brad) brad.right(10) brad.right(90) brad.forward(200) window.exitonclick()# 方形画圆draw_art()# 添加音乐 步骤 获取画布turtle.Screen()，设置背景色 获取画笔 turtle.Turtle()，设置画笔形状颜色速度等 画出想要的图案 源码地址Python-Exercies]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python练习题（一）--猜数字]]></title>
      <url>%2F2017%2F09%2F11%2FPython%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89-%E7%8C%9C%E6%95%B0%E5%AD%97%2F</url>
      <content type="text"><![CDATA[但行好事，莫问前程 最近发生了很多事情，整理整理最近的学习资料，一起发上来。 题目来源：《Python编程：从入门到实践》内容： 如何学习编写第一个程序，每个程序员都有不同的故事。我还是孩子是就开始学习变成了，当我的父亲在计算时代的先锋之一——数字设备公司（Digital Equipment Corporation）工作。我使用了一台简陋的计算机编写了第一个程序，这台计算机是父亲在家里的地下室组装而成的，他没有机箱，裸露的主板与键盘相连，显示器是裸露的阴极射线管。我编写的这个程序是一款简单的猜数字有习，其输出类似于下面这样。 效果： 我的解法12345678910111213141516import randomnum = random.randint(1,100)one = "I'm thinking of a number! Try to guess the number,You are thinking of:"print(one, end="")while 1: guessNumber = input() guessNumber = int(guessNumber) if guessNumber &gt; num: print("too high! Guess again:") elif guessNumber &lt; num: print("too low! Guess again:") else: print("That's it! You're smart") breakinput("点击 enter 键退出") 注意 print()默认换行，end=”\n” 改为 end=”” python 六个基本类型Number（数字）、String（字符串）、List（列表）、Tuple（元组）、Sets（集合）、Dictionary（字典） 没有布尔类型 input() 为输入的默认为str ， Python 不用申明类型（Python是强类型，动态类型检测语言），但需要显示类型转换（与js不同） 源码地址Python-Exercies]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年第一季度总结]]></title>
      <url>%2F2017%2F05%2F06%2F2017%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%AD%A3%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[种一棵树最好的时间是十年前,而后是现在 2017年第一季度，就这样平淡无奇的度过了，但我的确很早便预测到这一季度，包括这一年，都会我人生的分水岭。 大四了，既是第一段人生的末尾，意识第二段人生的开始，其最明显的标志应该为经济上的初步独立吧。虽然在经济上依旧没有抗压能力，但只要求平淡的生活，还是可以自给自足的。 仔细想想，今年的第一季度，确实也有不少收获。 个人大事件2017 年 2 月份，收获了第一份工作，站了 20 多个小时的火车，来到杭州打拼。2017 年 3 月份，搭建了自己的博客codinghjy，记录分享一些学习到的 Java 知识。2017 年 4 月份，找了个伴，游西湖。生活总是这样，明明感觉转变了很多，回头想想，还是平淡无奇。 新思维既然生活上没有新花样，那就谈谈思维上的转变吧，2017 年，思维确实产生翻天复地的变化。 第一点，最重要的一点，应该是思想觉悟的转变。这里的确应该感谢一个人，准确说是一个公众号，一个名为 AndroidDeveloper 的微信公众号，在我刚步入社会的迷茫期，赶上公众号作者事业的飞速发展期，每天看着作者分享的励志正能量，看着他的微信号文章从一开始几百人阅读到现在的上万阅读量，看着他从一个普通的 Android 开发者到现在收到 Google IO 2017 的邀请函。就这样一步步亲眼见证别人实现梦想的过程，对我产生非常强大的触动，也会影响我人生的轨迹。2017 年第一季度的转变，大多数也源于此。 第二点，意识到「写作」是值得一生去练习的能力。无论你是何种职业，写作都可以作为你的第二能力去培养。因为任何人随着时间的推移，年龄的增长，总会积累下很多的技能和经验，时间会促使内容的产生，写作保证内容的输出，把你的知识用文字表达出来，就能给你创造价值。更何况，近几年个人内容创作逐渐趋于主流，人们也越来越愿意接受知识付费的行为。写作本身也会产生很多附加的价值，例如「记录」，随时记录自己的想法或者疑惑，答案或者机会就会在将来的某一天悄然来临，再如「总结」，总结自身亦是巩固自身，可以更清晰认识自身，明确自己的位置和前进的方向。 第三点，也是最基本的一点，那就是努力吧，看了那么多通过努力奋斗实现走上人生巅峰的故事，还有什么好等待的呢，行动起来吧！ 最后正如我一开始所说，我早有预感，2017 年我的人生会发生巨大的改变，这仅仅是一个开始。感谢这个互联网时代]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring 中引入单元测试]]></title>
      <url>%2F2017%2F04%2F18%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[Spring 中引入单元测试操作步骤 下载 junit-*.jar 并引入项目中。 创建 UnitTestBase 类，完成对 Spring 配置文件的加载、销毁 所有的单元测试类都继承 UnitTestBase，通过它的 getBean 方法获取想要得到的对象 子类（具体执行单元测试的类）加注解：@RunWith(BlockJUnit4ClassRunner.class) 单元测试方法加注解：@Test 右键执行 UnitTestBase 类（加载 spring.xml 配置文件）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.imooc.test.base;import org.junit.After;import org.junit.Before;import org.springframework.beans.BeansException;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.util.StringUtils;public class UnitTestBase &#123; private ClassPathXmlApplicationContext context;// springxml的路径 private String springXmlpath; public UnitTestBase() &#123;&#125;// 构造器传入路径，子类构造器传入具体路径 public UnitTestBase(String springXmlpath) &#123; this.springXmlpath = springXmlpath; &#125;// 执行顺序 @Before -- @Test -- @After @Before public void before() &#123;// 判空处理 if (StringUtils.isEmpty(springXmlpath)) &#123; springXmlpath = "classpath*:spring-*.xml"; &#125; try &#123;// 上下文，Spring的容器// 查找配置文件中的配置信息，加载信息到context中，获取信息时使用context.getBean(String id)方法获取相应对象 context = new ClassPathXmlApplicationContext(springXmlpath.split("[,\\s]+")); context.start(); &#125; catch (BeansException e) &#123; e.printStackTrace(); &#125; &#125; @After public void after() &#123; context.destroy(); &#125;// context的bean方法 @SuppressWarnings("unchecked") protected &lt;T extends Object&gt; T getBean(String beanId) &#123; try &#123; return (T)context.getBean(beanId); &#125; catch (BeansException e) &#123; e.printStackTrace(); return null; &#125; &#125; protected &lt;T extends Object&gt; T getBean(Class&lt;T&gt; clazz) &#123; try &#123; return context.getBean(clazz); &#125; catch (BeansException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 注意： springxml为配置文件路径，构造器传入路径，子类构造器传入具体路径 执行顺序 @Before – @Test – @After @Before 中查找并加载配置信息，存放于 Spring 的容器 context 中，使用context.getBean获取相应对象。 @Test 子类中需要测试的方法 @After 关闭context]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[专题二：Bean ---- Spring入门笔记]]></title>
      <url>%2F2017%2F04%2F18%2FSpring%E5%85%A5%E9%97%A8-1%2F</url>
      <content type="text"><![CDATA[专题二 Bean主要内容： Bean 配置项 Bean 的作用域 Bean 的生命周期 Bean 的自动装配 Resources &amp; ResourceLoader Bean 主要配置项 Id （获取 bean） Class （获取 bean）【必须】 Scope 范围 Constructor arguments 构造器参数 （构造注入） Properties 属性（设置注入） Autowiring mode 自动装配模式 lazy-initialization mode 懒加载模式 Initialization/destruction method 初始化和销毁方法 Bean 的作用域 singleton : 单例，指一个 Bean 容器中只存在一份，context 只存在一份 prototype : 每次请求（每次使用）创建新的实例，destroy 方式不生效 request : 每次 http 请求创建一个实例且仅在当前 request 内有效 session：同上 global session：基于 portlet 的 web 中有效（portlet 定义了 global session），如果是 web 中，同 session Bean 的作用域案例Bean 类 12345678package com.imooc.bean;public class BeanScope &#123; public void say() &#123; System.out.println("BeanScope say : " + this.hashCode()); &#125;&#125; spring 配置 Beanspring-beanscope.xml123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" &gt; &lt;bean id="beanScope" class="com.imooc.bean.BeanScope" scope="singleton"&gt;&lt;/bean&gt; &lt;/beans&gt; 单元测试方法12345678910111213141516171819@RunWith(BlockJUnit4ClassRunner.class)public class TestBeanScope extends UnitTestBase &#123; public TestBeanScope() &#123; super("classpath*:spring-beanscope.xml"); &#125; @Test public void testSay() &#123; //BeanScope scope=singleton 单例 //beanScope 和 beanScope2 的 hashCode 相同 BeanScope beanScope = super.getBean("beanScope"); beanScope.say(); BeanScope beanScope2 = super.getBean("beanScope"); beanScope2.say(); &#125;&#125; 执行单元测试 testSay 方法，发现 beanScope 和 beanScope2 的 hashCode 相同，因为 scope = singleton 同一份容器中只会出现一个 bean。执行结果将 xml 文件中 singleton 改为 prototype，重新执行，执行结果 Bean 的生命周期 生命周期 定义 springxml 配置 bean 初始化 context 加载 springxml，context.start() 初始化 使用 从 Bean 容器中获取使用 销毁 Bean 容器销毁所有 Bean 实例 Bean 初始化方法 实现 org.springframework.beans.factory.InitializingBean 接口，覆盖afterPropertiesSet 方法。 配置 init-method Bean 销毁 实现 org.springframework.beans.factory.DisposableBean 接口，覆盖 destory 方法 配置 destroy-method 配置全局默认初始化、销毁方法 注：当三种方法同时使用时，先执行接口方法，然后执行 bean 配置方法，不执行默认方法。 Aware 获取资源 实现 Aware 接口的 bean 在被初始化之后，可以获取相应资源 通过 Aware 接口，可以操作 Spring 的相应资源（慎重）。 对 Spring 的简单扩展提供入口 常用 Aware 接口 ApplicationContextAware 提供 context 上下文信息 BeanNameAware 提供 BeanName（BeanId） ApplicationEventPublisherAware BeanFactoryAware BootstrapContextAware ServletConfigAware注：一般是同时实现 ApplicationContextAware 和 BeanNameAware 接口，获取到 Bean 的 Id，利用 context.getBean(id) 获取其他 Bean 资源。 Bean 的自动装配（Autowiring） （自动注入） NO：不做任何操作 byname：根据属性名自动装配 byType：装配（一个）类型相同的 Bean ，（多个）报错 Constructor：装配配合（参数类型一致）的构造器例子1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-autowire="constructor"&gt;&lt;!-- 自动装配属性 default-autowire=“NO/byname” --&gt; &lt;bean id="autoWiringService" class="com.imooc.autowiring.AutoWiringService" &gt;&lt;/bean&gt; &lt;bean class="com.imooc.autowiring.AutoWiringDAO" &gt;&lt;/bean&gt; &lt;/beans&gt; Resources &amp;&amp; ResourceLoader 针对资源文件的统一接口 Resource UrlResource：Url对应的资源 ClassPathResource：获取类路径下的资源文件 FIleSystemResource：文件系统下资源 ServletContextResource：web 环境下可以访问的资源 InputStreamResource：输入流封装的资源 ByteArrayResource：字节数组封装的资源 ResourceLoader 所有 application context 都实现 ResourceLoader 接口 加载 Resource 资源类 前缀：classpath/file/http/none(application context)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生AJAX实现搜索框智能提示]]></title>
      <url>%2F2017%2F03%2F31%2FAJAX%2F</url>
      <content type="text"><![CDATA[前言一直以来，使用 JQuery 来实现 AJAX 请求，感觉有必要了解一下原生 JS 实现方式。 AJAX介绍概念 AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。 优点 使用Ajax的最大优点，就是能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变的信息。 缺点 它破坏浏览器的后退与加入收藏书签功能。 解决方案 HTML5之前的一种方式是使用URL片断标识符（通常被称为锚点，即URL中#后面的部分）来保持追踪，允许用户回到指定的某个应用程序状态。（许多浏览器允许JavaScript动态更新锚点，这使得Ajax应用程序能够在更新显示内容的同时更新锚点。） HTML5 以后可以直接操作浏览历史，并以字符串形式存储网页状态，将网页加入网页收藏夹或书签时状态会被隐形地保留。 Js通用代码跨浏览器的通用方法123456789var xmlHttp;if (typeof XMLHttpRequest != "undefined") &#123; xmlHttp = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; var aVersions = ["Msxml2.XMLHttp.5.0", "Msxml2.XMLHttp.4.0", "Msxml2.XMLHttp.3.0", "Msxml2.XMLHttp", "Microsoft.XMLHttp"]; for (var i = 0; i &lt; aVersions.length; i++) &#123; try &#123; xmlHttp = new ActiveXObject(aVersions[i]); break; &#125; catch (e) &#123;&#125; &#125;&#125; 本项目介绍 搜索框智能提示的应用场景 掌握搜索框智能提示的原理 自己动手开发搜索框智能提示的功能 值得关注的点：原生 js 获取 xmlHttp 对象，前后台交互方法 应用场景搜索框，模糊搜索等 理论分析 在搜索框输入关键字 浏览器将关键字「异步」发送给服务器 服务器经过处理。将相应数据以 Json 格式返回客户端 浏览器接受服务器响应数据，解析之后使用 js 操作 dom 显示数据。 图片解析流程 重点一：数据交互采用 ajax 方式重点二：javascript 解析数据动态展示 项目核心源码分享与 Github 的 ServletAjax 项目]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[专题一：IOC ---- Spring入门笔记]]></title>
      <url>%2F2017%2F03%2F27%2FSpring%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[专题一 IOC 接口及面向接口编程 什么是 IOC（控制反转）：控制权转移，应用程序本身不负责 Spring的 Bean 配置 Bean 的初始化 Spring 的常用注入方式 接口及面向接口编程接口 接口即声明，声明哪些方法对外提供。 使用接口沟通，使其能被修改内部而不影响外部其他实体的与其交互的方式（Java8中接口可以拥有方法体） 面向接口编程 结构设计中，分清层次及调用关系，每层只向外（上层）提供一组功能的接口，各层仅依赖接口而非实现类 接口内部的实现变动不影响各层之间的调用，这一点在公共服务中尤为重要 “面向接口编程”中的“接口”是用于【隐藏具体的实现】和【实现多态性的组件】（2点） 什么是IOC IOC：控制反转，控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护 DI（依赖注入）是其一种实现方式。（获取依赖对象的过程被反转，过程由自身管理变为有 IOC 容器主动注入，即依赖注入） 目的：创建对象并且组装对象之间的关系 下图为 Spring 官网给出的 IOC 说明 Spring 的 Bean 配置配置一般存放于 spring-ioc.xml 文件中举例1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" &gt; &lt;bean id="oneInterface" class="com.imooc.ioc.interfaces.OneInterfaceImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; Bean 容器的初始化 基础：两个包 org.springframework.beans org.springframework.context BeanFactory 提供配置结构和基本功能，加载并初始化Bean ApplicationContext 保存了 Bean 对象并在 Spring 中广泛使用 3中初始化方式：ApplicationContext 本地文件 12FileSystemXmlApplicationContext context = newFileSystemXmlApplicationContext("F:/workspace/appcontext.xml"); Classpath 12ClassPathXmlApplicationContext context = newClassPathXmlApplicationContext("classpath:spring-context.xml"); Web 应用中依赖 servlet 或 Listener Spring 注入 Spring 注入指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为 常用的两种注入方式 设值注入 构造注入 设值注入123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" &gt; &lt;bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl"&gt; &lt;property name="injectionDAO" ref="injectionDAO"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="injectionDAO" class="com.imooc.ioc.injection.dao.InjectionDAOImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 注意：需要在 Service 文件中添加 setInjectionDAO 方法。property 中 name 对应 set* 构造注入123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" &gt; &lt;bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl"&gt; &lt;constructor-arg name="injectionDAO" ref="injectionDAO"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="injectionDAO" class="com.imooc.ioc.injection.dao.InjectionDAOImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 注意：需要在 Service 文件中添加构造方法。name 对应 service 中构造器参数名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java练习项目分享]]></title>
      <url>%2F2017%2F03%2F26%2FJava%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%E5%88%86%E4%BA%AB%2F</url>
      <content type="text"><![CDATA[Java一味的学习只会使人感觉枯燥和无聊，在学习Java的过程中，我们总需要一些Java练习案例去检验自己的学习成果，这里给大家分享一些我自己的Java练习项目。 项目介绍本项目是个人的一些java项目练习源码，分享给大家，希望可以和大家一起进步！ Java项目实例 Woss2.0 电信采集系统 123适合java完全入门者练习，涉及到接口，xml解析，log4j应用。难度： 一般需要知识: IO流 多线程 网络编程 jdbc tomcatServlet3.0 Web服务器 123模拟tomcat服务器，帮助了解http协议难度： 易需要知识： 多线程 网络编程 checkcode Java制作验证码 123慕课教程Java制作验证码，不想看视频的可以看看难度：易需要知识： jsp/servlet 基础 IMOOCSpider 简易网络爬虫 123爬取慕课猿问问题难度：易需要知识：java基础语法，正则表达式 联系所有项目源码分享在github上，查看源码请点击——这里Please feel free to contact us with any questions you may have.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java网络爬虫项目]]></title>
      <url>%2F2017%2F03%2F19%2Fjava%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[talk is cheap, show me the code; 什么是网络爬虫？维基百科 网络爬虫（英语：web crawler），也叫网络蜘蛛（spider），是一种用来自动浏览万维网的网络机器人。其目的一般为编纂网络索引。 百度百科 网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 java网络爬虫练习项目一个比较简单的java练习项目。 需要知识 什么是网络爬虫 Java基础 正则表达式 项目思路在慕课网的猿问页面，寻找一个你喜欢的问题页面，利用http请求获取问题页面的源码，然后通过正则表达式，不断爬取相关问题页面。 项目介绍该项目存在三个类Imooc.java : imooc问题bean类Spider.java: 封装用来爬取页面的方法类Main.java: 运行起始页面 Imooc.java类是要爬取内容的对象类，属性成员有问题，问题链接，问题描述，答案列表和下一个问题链接。 Spider.java类封装了2个可能用到的方法，getSource方法获取网页源代码和getImoocPage获取页面Url列表。 项目源码IMOOCSpider项目已上传到我的github上—-传送门欢迎Star 下载下来后导入eclipse即可运行。 项目运行结果 推荐java爬取知乎问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA随机生成验证码（一）]]></title>
      <url>%2F2017%2F03%2F08%2FJAVA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[图片验证码原理： 服务器生成包含随机字符的字符串图片发给客户端，客户端提交数据需要填写字符串作为验证。而字符串保存在图片中，机器难以识别，达到防止有人利用程序恶意发送信息的目的。 JAVA随机生成图片JAVA随机生成图片步骤如下： 创建图片缓存区 传参为宽高和图片类型 12BufferedImage bi = newBufferedImage(width,height,BufferedImage.TYPE_INT_RGB); 获取画笔并绘画 1234Graphics g = bi.getGraphics(); //获取画笔g.setFont(new Font(Font.SANS_SERIF,Font.BOLD,16));//设置字体g.setColor(color);//设置画笔颜色g.fillRect(0, 0, width, height); //绘制背景 输出图片 1ImageIO.write(bi, "JPG", resp.getOutputStream()); JAVA实现验证码实例servlet生成验证码图片源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.javaweb.respones;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class IdentityServlet extends HttpServlet&#123;// 设置字符 public static final char[] chars="1234567890QWERTYUIOPASDFGHJKLZXCVBNM".toCharArray();// 设置随机数 public static Random random = new Random();// 获取4位随机数 public static String getRandomString()&#123; StringBuffer buffer = new StringBuffer(); int index; //获取随机chars下标 for(int i=0;i&lt;4;i++)&#123; index = random.nextInt(chars.length); //获取随机chars下标 buffer.append(chars[index]); &#125; return buffer.toString(); &#125;// 获取随机颜色 public static Color getRandomColor()&#123; return new Color(random.nextInt(255),random.nextInt(255),random.nextInt(255)); &#125;// 返回某颜色的反色 public static Color getReverseColor(Color c)&#123;// 防止反色和原色相近 if(c.getRed()&lt;130&amp;&amp;c.getRed()&gt;125 &amp;&amp; c.getBlue()&lt;130&amp;&amp; c.getBlue()&gt;125 &amp;&amp; c.getGreen()&lt;130&amp;&amp;c.getGreen()&gt;125)&#123; return new Color(255,255,255); &#125;else&#123; return new Color(255-c.getRed(),255-c.getGreen(),255-c.getBlue()); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String code = getRandomString(); //获取随机验证码 req.getSession().setAttribute("code", code); //放入Session int width = 100; //图片宽度 int height = 30; //图片高度 Color color = getRandomColor(); //随机色，用于背景色 Color reverse = getReverseColor(color); //反色，用于前景色 /** * 生成带字符串的文本图片 */// 1.创建图片缓存区 传参为宽高和图片类型 BufferedImage bi = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);// 2.获取画笔并绘画 Graphics g = bi.getGraphics(); g.setFont(new Font(Font.SANS_SERIF,Font.BOLD,16));//设置字体 g.setColor(color);//设置画笔颜色 g.fillRect(0, 0, width, height); //绘制背景 g.setColor(reverse); //设置画笔颜色 g.drawString(code, 18, 20); //绘制字符// 设置最多100个噪音点 for(int i=0,n = random.nextInt(100);i&lt;n;i++)&#123; g.drawRect(random.nextInt(width), random.nextInt(height), 1, 1); &#125;// 3.输出图片 ImageIO.write(bi, "JPG", resp.getOutputStream()); &#125;&#125; 生成图片验证码主要应用随机数生成器Random生成随机颜色绘制背景，取反色*绘制字符,并绘制最多100随机位置的噪音点，增加识别难度。 配置XML12345678&lt;servlet&gt; &lt;servlet-name&gt;IdentityServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.javaweb.respones.IdentityServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;IdentityServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/IdentityServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; html展示页面1234567891011121314&lt;head&gt; &lt;script type="text/javascript"&gt; function reloadImage()&#123; document.getElementById('btn').disable=true; document.getElementById('identity').src='servlet/IdentityServlet?time=' +new Date().getTime(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src = "servlet/IdentityServlet" id="identity" onload="btn.disabled= false;"&gt; &lt;input type="button" value="换个图片" onclick="reloadImage()" id="btn"&gt; &lt;/body&gt; 截图展示 下篇介绍利用组件Jcaptcha和Kaptcha生成验证码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[现代浏览器之争]]></title>
      <url>%2F2017%2F03%2F03%2F%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BA%89%2F</url>
      <content type="text"><![CDATA[今天学习javaweb，发现一件很有趣的事情…… 用浏览器访问servlet项目，当代码执行到这地方时1234567891011121314151617/** * * 返回客户端浏览器信息 */private String getNavigator(String userAgent)&#123; if(userAgent.indexOf("TencentTraveler") &gt; 0) return "腾讯浏览器"; if(userAgent.indexOf("Safari")&gt;0) return "Safari浏览器"; if(userAgent.indexOf("Chrome")&gt;0) return "Chrome浏览器"; if(userAgent.indexOf("Firefox")&gt;0) return "Firxfox浏览器"; if(userAgent.indexOf("MSIE")&gt;0) return "IE浏览器"; return "未知浏览器";&#125; 使用谷歌浏览器访问，居然辨识出错 打开调试器，发现谷歌的userAgent竟然有这么多的浏览器标识,这是什么情况！！！谷歌在伪装别人么… 查阅各方资料，终于找到答案： 为什么所有浏览器的userAgent都带Mozilla 最早的时候有一个浏览器叫NCSA Mosaic，把自己标称为NCSA_Mosaic/2.0 (Windows 3.1)，它支持文字显示的同时还支持图片，于是Web开始好玩起来。 然后出现了一个新的网页浏览器，“Mozilla”，其实就是“Mosaic终结者”的意思，这搞的Mosaic很不爽，（毕竟Mosaic出道早，江湖老），新浏览器最后正式公布的名称是Netscape，它把自己标称为Mozilla/1.0 (Win3.1)，更好玩了。Netscape支持框架显示，后来框架在大家中间流行起来了，但Mosaic不支持框架啊，于是伟大的“用户代-理人探测”技术出现了，如果是“Mozilla”，那就发给支持框架的页面，至于其他的浏览器，则发给不含框架的页面。 Netscape想逗Microsoft玩儿，把Windows叫做“几乎不曾做过调试的设备驱动器”，后者很恼火。Microsoft于是推出了自己的 网页浏览器，叫做Internet Explorer，希望它能成为“Netscape终结者”。Internet Explorer也支持框架，但它不是Mozilla啊，所以没人给它发送带有框架的页面。Microsoft慢慢烦躁起来，不再寄希望于网站管理员逐渐 认识IE并给它发框架，而是宣称自己是“兼容Mozilla”的，开始模仿Netscape，把自己标称为Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)，这样Internet Explorer也能收到框架了，整个Microsoft狂喜，但网站管理员开始有点被搞糊涂了。 Microsoft把IE和Windows一起卖，并且把产品也弄得比Netscape更好了，拉开了第一场浏览器之战。结果和大家知道的一样，Netscape被干掉了，Microsoft大胜、大喜。但是后来Netscape以Mozilla的新名称重生了，构造了Gecko，标称其为Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.1) Gecko/20020826，Gecko属于渲染引擎，表现优异。Mozilla开发了Firefox，标称为Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0，并且Firefox表现也非常优秀。Gecko扩张迅速，一些浏览器使用了它的代码并标称为Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7.2) Gecko/20040825 Camino/0.8.1 ，这是一个，还有Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.8) Gecko/20071008 SeaMonkey/1.0，另一个，它们都伪装成Mozilla，同时也都是基于Gecko支持的。 Gecko表现优秀，IE则很差劲，于是身份甄别再次发生，输送给Gecko的是设计良好的网页代码，其他浏览器就没有这个待遇了。Linux的跟随者很伤心，因为他们创建了基于KHTML引擎支持的Konqueror，但却不会被输送好代码，虽然他们自己认为KHTML和Gecko一样优秀，于是Konquerer开始伪装自己“像Gecko”那样以得到好的网页，并标称自己为Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)，这个世界更让人困惑了。 后来出现了Opera这样的主儿，宣称“允许用户自己决定让浏览器装成谁”，它的菜单中提供了Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51， Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51，Opera/9.51 (Windows NT 5.1; U; en) 供大家来选择，选谁是谁。 Apple开发了Safari，使用了KHTML，同时也增加了很多新特性，后来干脆一锅煮，另起炉灶叫了WebKit，但是它有希望能够得到那些为KHTML编写的网页，于是Safari标称自己为Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5，这个世界更混乱了。 Microsoft越来越担心Firefox的发展，重新启动了Internet Explorer的开发，标称自己为Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0) ，可以很好的渲染代码，但那要看网站管理员是否指示它这么做。 Google也开发了自己的浏览器Chrome， 使用了Webkit，有点像Safari，希望能得到为Safari编写的网页，于是决定装成Safari。这样啊，Chrome使用了WebKit渲染 引擎，想装成Safari，而WebKit呢又伪装自己是KHTML，KHTML呢又是伪装成Gecko的，同时所有的浏览器又都宣称自己是 Mozilla，于是，Chrome宣称自己是Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13,，UserAgent字符串彻底混乱了，也几乎不再发挥任何作用，每个人都宣称自己是别人，混乱充斥人间啊。 有点调侃的味道，可以总结为一句话：Mozilla是Netscape的吉祥物，也是Netscape Navigator浏览器使用的内部开发代号。由于Netscape早期的影响力，直到今天，所有浏览器包括IE，向Web服务器报告自己的浏览器标识的 时候，都以 “Mozilla”开头，表明自己是Mozilla兼容的。这，就是原因啦。 查看浏览器标记的方法也很容易，通过JavaScript语句： javascript:alert(navigator.userAgent) 在地址栏输入以上代码，然后回车。 答案内容转载： http://www.eamonning.com/blog/view/289]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇博客]]></title>
      <url>%2F2017%2F03%2F02%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[做人没有梦想，跟咸鱼有什么区别 为什么写博客这个问题网上的答案数不胜数为什么要写博客我为什么坚持写博客对于个人而言 记录自身成长过程是多么有意义的一件事。 网上资料数不胜数，内容参差不齐，遇到问题自己整理解决并记录下来，供自己今后学习，也方便他人查阅。 寻找志同道合的朋友 为了保持逼格，不要停止写作 现阶段现阶段奋战javaWeb开发 个性签名talk is cheap, show me the code; 联系最后，如果你想联系我，请点击以下链接： Blog@codinghjy Github@codinghjy jianshu@codinghjy 再说两句如果你想搭建想我一样酷炫的Blog请点击这里—&gt;传送门]]></content>
    </entry>

    
  
  
</search>
